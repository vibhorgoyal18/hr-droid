{"version":3,"sources":["ng://@wellwind/thanos-snap/lib/thanos-snap.ts"],"names":["sampler","layerImages","sourceImgData","width","height","layerCount","length","range","forEach","x","y","n","pieceIndex","Math","floor","random","pixelPos","rgbaIndex","dataPos","data","transformLayerCanvas","canvas","rotate1","rotate2","fac","PI","translateX","cos","translateY","sin","style","transform","opacity","removeDelay","TRANSITION_DURATION","setTimeout","remove","backingScale","window","devicePixelRatio","thanosRewind","target","Promise","resolve","visibility","html2canvas","html2canvas_","effect","document","createElement","classList","add","parentNode","insertBefore","targetRect","getBoundingClientRect","then","context","getContext","position","left","top","imgData","getImageData","map","_","createImageData","effectImage","index","newCanvas","transition","putImageData","appendChild","transitionDelay","rewind"],"mappings":"uVAUgB,SAAVA,EACJC,EACAC,EACAC,EACAC,GAEA,IAAMC,EAAaJ,EAAYK,OAE/BC,EAAAA,MAAM,EAAGJ,GAAOK,QAAQ,SAAAC,GACtBF,EAAAA,MAAM,EAAGH,GAAQI,QAAQ,SAAAE,GACvBH,EAAAA,MAAM,EAHK,GAGMC,QAAQ,SAAAG,GAKvB,IAJA,IAAMC,EAAaC,KAAKC,MACrBT,GAAcQ,KAAKE,SAAY,EAAIN,EAAKN,GAAU,GAE/Ca,EAAW,GAAKN,EAAIP,EAAQM,GACzBQ,EAAY,EAAGA,EAAY,EAAGA,IAAa,CAClD,IAAMC,EAAUF,EAAWC,EAC3BhB,EAAYW,GAAYO,KAAKD,GAAWhB,EAAciB,KAAKD,UAOxC,SAAvBE,EAAwBC,GAC5B,IAAMC,EAAU,IAAMT,KAAKE,SAAW,IAChCQ,EAAU,IAAMV,KAAKE,SAAW,IAChCS,EAAM,EAAIX,KAAKY,IAAMZ,KAAKE,SAAW,IACrCW,EAAa,GAAKb,KAAKc,IAAIH,GAC3BI,EAAa,GAAKf,KAAKgB,IAAIL,GAEjCH,EAAOS,MAAMC,UAAY,UAAUT,EAAO,kBAAkBI,EAAU,OAAOE,EAAU,cAAcL,EAAO,OAC5GF,EAAOS,MAAME,QAAU,IAEvB,IAAMC,EAAc,KAAOC,IAA0BrB,KAAKE,UAC1DoB,WAAW,WAAM,OAAAd,EAAOe,UAAUH,GAKf,SAAfI,IACJ,OAAIC,OAAOC,kBAA8C,EAA1BD,OAAOC,iBAC7BD,OAAOC,iBAET,EAGmB,SAAfC,EAAgBC,GAC3B,OAAA,IAAIC,QAAQ,SAAAC,GACVF,EAAOX,MAAME,QAAU,IACvBS,EAAOX,MAAMc,WAAa,UAC1BD,MAzDJ,IAAME,EAAcC,4CA4DM,SAACL,GACzB,OAAA,IAAIC,QAA8B,SAAAC,GAChC,IAAMI,EAASC,SAASC,cAAc,OACtCF,EAAOG,UAAUC,IAAI,UACrBV,EAAOW,WAAWC,aAAaN,EAAQN,GACvC,IAAMa,EAAab,EAAOc,wBAE1BV,EAAYJ,GAAQe,KAAK,SAACnC,GACxB,IAAMoC,EAAUpC,EAAOqC,WAAW,MAClCX,EAAOjB,MAAM6B,SAAW,WACxBZ,EAAOjB,MAAM8B,KAAON,EAAWM,KAAO,KACtCb,EAAOjB,MAAM+B,IAAMP,EAAWO,IAAM,KACpCd,EAAOjB,MAAM3B,MAAQmD,EAAWnD,MAAQ,KACxC4C,EAAOjB,MAAM1B,OAASkD,EAAWlD,OAAS,KAElC,IAAAD,EAAAkB,EAAAlB,MAAOC,EAAAiB,EAAAjB,OAGT0D,EAAUL,EAAQM,aAAa,EAAG,EAAG5D,EAAOC,GAE5CH,EAAcM,EAAAA,MAAM,EA9EjB,IA8E4ByD,IAAI,SAAAC,GACvC,OAAAR,EAAQS,gBAAgB/D,EAAOC,KAEjCJ,EAAQC,EAAa6D,EAAS3D,EAAOC,GAErCH,EAAYO,QAAQ,SAAC2D,EAAaC,GAChC,IAAMC,EAAYrB,SAASC,cAAc,UAEzCoB,EAAUvC,MAAM6B,SAAW,WAC3BU,EAAUvC,MAAMwC,WAAa,WAE7BD,EAAUlE,MAAQmD,EAAWnD,MAAQkC,IACrCgC,EAAUjE,OAASkD,EAAWlD,OAASiC,IAEvCgC,EAAUvC,MAAM3B,MAAWkE,EAAUlE,MAAQkC,IAAc,KAC3DgC,EAAUvC,MAAM1B,OAAYiE,EAAUjE,OAASiC,IAAc,KAE1CgC,EAAUX,WAAW,MAC7Ba,aAAaJ,EAAa,EAAG,GAExCpB,EAAOyB,YAAYH,GAEnB,IAAMI,EAAsCL,EAAQnE,EAAYK,OAlG/C,KAmGjB+D,EAAUvC,MAAM2C,gBAAqBA,EAAe,IAEpDtC,WAAW,WAAM,OAAAf,EAAqBiD,IAAY,KAGpD5B,EAAOX,MAAMwC,WAAa,mBAC1B7B,EAAOX,MAAME,QAAU,IAEvBG,WAAW,WACTM,EAAOX,MAAMc,WAAa,SAC1BG,EAAOX,SACPO,EAAQ,CACN+B,OAAQ,WAAM,OAAAlC,EAAaC,OAE5B","sourcesContent":["// to fix error: Cannot call a namespace ('html2canvas')\r\nimport * as html2canvas_ from 'html2canvas';\r\nimport { range } from 'ramda';\r\n\r\nconst html2canvas = html2canvas_;\r\n\r\nconst LAYERS = 32;\r\nconst TRANSITION_DURATION = 1.5;\r\nconst TRANSITION_DELAY = 1.35;\r\n\r\nconst sampler = (\r\n  layerImages: ImageData[],\r\n  sourceImgData: ImageData,\r\n  width: number,\r\n  height: number\r\n) => {\r\n  const layerCount = layerImages.length;\r\n  const repeat = 2;\r\n  range(0, width).forEach(x => {\r\n    range(0, height).forEach(y => {\r\n      range(0, repeat).forEach(n => {\r\n        const pieceIndex = Math.floor(\r\n          (layerCount * (Math.random() + (2 * x) / width)) / 3\r\n        );\r\n        const pixelPos = 4 * (y * width + x);\r\n        for (let rgbaIndex = 0; rgbaIndex < 4; rgbaIndex++) {\r\n          const dataPos = pixelPos + rgbaIndex;\r\n          layerImages[pieceIndex].data[dataPos] = sourceImgData.data[dataPos];\r\n        }\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\nconst transformLayerCanvas = (canvas: HTMLCanvasElement) => {\r\n  const rotate1 = 15 * (Math.random() - 0.5);\r\n  const rotate2 = 15 * (Math.random() - 0.5);\r\n  const fac = 2 * Math.PI * (Math.random() - 0.5);\r\n  const translateX = 60 * Math.cos(fac);\r\n  const translateY = 30 * Math.sin(fac);\r\n\r\n  canvas.style.transform = `rotate(${rotate1}deg) translate(${translateX}px, ${translateY}px) rotate(${rotate2}deg)`;\r\n  canvas.style.opacity = '0';\r\n\r\n  const removeDelay = 1e3 * (TRANSITION_DURATION + 1 + Math.random());\r\n  setTimeout(() => canvas.remove(), removeDelay);\r\n};\r\n\r\n// fix retina problem\r\n// https://github.com/cburgmer/rasterizeHTML.js/blob/master/examples/retina.html\r\nconst backingScale = () => {\r\n  if (window.devicePixelRatio && window.devicePixelRatio > 1) {\r\n    return window.devicePixelRatio;\r\n  }\r\n  return 1;\r\n};\r\n\r\nexport const thanosRewind = (target: HTMLElement) =>\r\n  new Promise(resolve => {\r\n    target.style.opacity = '1';\r\n    target.style.visibility = 'visible';\r\n    resolve();\r\n  });\r\n\r\nexport const thanosSnap = (target: HTMLElement) =>\r\n  new Promise<{ rewind: () => {} }>(resolve => {\r\n    const effect = document.createElement('div');\r\n    effect.classList.add('thanos');\r\n    target.parentNode.insertBefore(effect, target);\r\n    const targetRect = target.getBoundingClientRect();\r\n\r\n    html2canvas(target).then((canvas: HTMLCanvasElement) => {\r\n      const context = canvas.getContext('2d');\r\n      effect.style.position = 'absolute';\r\n      effect.style.left = targetRect.left + 'px';\r\n      effect.style.top = targetRect.top + 'px';\r\n      effect.style.width = targetRect.width + 'px';\r\n      effect.style.height = targetRect.height + 'px';\r\n\r\n      const { width, height } = canvas;\r\n\r\n      // get element imageData\r\n      const imgData = context.getImageData(0, 0, width, height);\r\n\r\n      const layerImages = range(0, LAYERS).map(_ =>\r\n        context.createImageData(width, height)\r\n      );\r\n      sampler(layerImages, imgData, width, height);\r\n\r\n      layerImages.forEach((effectImage, index) => {\r\n        const newCanvas = document.createElement('canvas');\r\n\r\n        newCanvas.style.position = 'absolute';\r\n        newCanvas.style.transition = `all ${TRANSITION_DURATION}s`;\r\n\r\n        newCanvas.width = targetRect.width * backingScale();\r\n        newCanvas.height = targetRect.height * backingScale();\r\n\r\n        newCanvas.style.width = `${newCanvas.width / backingScale()}px`;\r\n        newCanvas.style.height = `${newCanvas.height / backingScale()}px`;\r\n\r\n        const newContext = newCanvas.getContext('2d');\r\n        newContext.putImageData(effectImage, 0, 0);\r\n\r\n        effect.appendChild(newCanvas);\r\n\r\n        const transitionDelay = TRANSITION_DELAY * (index / layerImages.length);\r\n        newCanvas.style.transitionDelay = `${transitionDelay}s`;\r\n\r\n        setTimeout(() => transformLayerCanvas(newCanvas), 0);\r\n      });\r\n\r\n      target.style.transition = `opacity ${TRANSITION_DURATION} ease`;\r\n      target.style.opacity = '0';\r\n\r\n      setTimeout(() => {\r\n        target.style.visibility = 'hidden';\r\n        effect.remove();\r\n        resolve({\r\n          rewind: () => thanosRewind(target)\r\n        });\r\n      }, 1e3 * TRANSITION_DURATION);\r\n    });\r\n  });\r\n"]}